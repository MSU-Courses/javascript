# Функции

Функции играют ключевую роль в программировании, обеспечивая модульность, повторное использование кода и, что не менее важно, порядок в голове разработчика. Код без функций напоминает длинный монолог без абзацев: формально читать можно, но быстро устаёшь и легко потеряться.

Можно ли обойтись без функций? В целом - да, технически возможно. Рекомендуется ли? Нет. Категорически.

Учитывая ваш опыт работы с функциями в курсе по основам программирования и знакомство с некоторыми встроенными функциями JavaScript (`alert()`, `prompt()`, `console.log()` и другими), вы уже интуитивно понимаете, зачем они нужны. Однако в JavaScript функции ведут себя немного "по-другому". Из-за этого они способны сбить с толку не только новичков, но и вполне опытных разработчиков.

## Содержание

- [Функции](#функции)
  - [Содержание](#содержание)
  - [Что такое функция?](#что-такое-функция)
  - [Когда использовать функции?](#когда-использовать-функции)
    - [Избежание дублирование кода](#избежание-дублирование-кода)
    - [Повышение читаемости и поддерживаемости кода](#повышение-читаемости-и-поддерживаемости-кода)
  - [Объявление и вызов функции](#объявление-и-вызов-функции)
    - [Объявление функции](#объявление-функции)
    - [Вызов функции](#вызов-функции)
  - [Область видимости переменных функции](#область-видимости-переменных-функции)
    - [Локальная область видимости](#локальная-область-видимости)
    - [Доступ к внешним переменным](#доступ-к-внешним-переменным)
    - [Вложенные функции и цепочка областей видимости](#вложенные-функции-и-цепочка-областей-видимости)
    - [Перекрытие переменных](#перекрытие-переменных)
  - [Возвращение значения](#возвращение-значения)
  - [Параметры и аргументы функции](#параметры-и-аргументы-функции)
    - [Различие между параметрами и аргументами](#различие-между-параметрами-и-аргументами)
    - [Передача аргументов в функцию](#передача-аргументов-в-функцию)
    - [Параметры по умолчанию](#параметры-по-умолчанию)
    - [Остаточные параметры](#остаточные-параметры)
  - [Function Expression](#function-expression)
    - [Что такое функция в контексте JavaScript?](#что-такое-функция-в-контексте-javascript)
    - [Синтаксис Function Expression](#синтаксис-function-expression)
    - [Различия Function Declaration и Function Expression](#различия-function-declaration-и-function-expression)
      - [Способ объявления](#способ-объявления)
      - [Hoisting](#hoisting)
    - [Когда использовать Function Declaration и Function Expression?](#когда-использовать-function-declaration-и-function-expression)
  - [Теперь вы знаете ...](#теперь-вы-знаете-)

## Что такое функция?

Вспомним школьную программу по математике.

В математике _функция_ - это правило, которое:

- Принимает некоторое значение (аргумент),
- Выполняет над ним определённое действие,
- Возвращает результат.

Например:

```
f(x) = x²
```

В программировании идея ровно та же, только чуть более легче.

В программировании _функция_ - это блок кода, который может принимать параметры, выполняет определенные действия и возвращает результат. Простыми словами, функция - это именованное действие, которое можно вызвать в нужный момент, например: `посчитать_объем_куба`.

> [!TIP]
>
> В курсе по основам программирования вы могли встречать понятие _процедура_.
> _Процедура_ - это именованное действие, которое не возвращает значение.
> В JavaScript отдельного понятия процедуры нет: все такие конструкции называются функциями.

## Когда использовать функции?

В программировании функции используются повсеместно. Существует две основные причины, по которым стоит применять функции:

- Избежание дублирования кода и обеспечение его переиспользования в разных частях программы.
- Повышение читаемости и поддерживаемости кода.

### Избежание дублирование кода

_Пример без использования функций (плохой подход)_

```js
// Файл: index.js
let circleRadius = 5;
let circleArea = Math.PI * circleRadius ** 2;
console.log('Площадь круга:', circleArea);

// Файл: calculate.js
let circleRadius = 10;
let circleArea = Math.PI * circleRadius ** 2;
console.log('Площадь круга:', circleArea);

// Один и тот же код дублируется в разных частях программы
```

В таком подходе одна и та же логика повторяется. Если формула изменится, правки придётся вносить в нескольких местах, что неудобно и приводит к ошибкам.

_Использование функции (хороший подход)_

```js
// Функция для вычисления площади круга
function calculateCircleArea(radius) {
  return Math.PI * radius ** 2;
}

// Файл: index.js
let circleRadius = 5;
console.log('Площадь круга:', calculateCircleArea(circleRadius));

// Файл: calculate.js
let circleRadius = 10;
console.log('Площадь круга:', calculateCircleArea(circleRadius));
```

Теперь логика вычисления вынесена в отдельную функцию `calculateCircleArea`. Её можно использовать сколько угодно раз, передавая нужный радиус, не дублируя код и не рискуя ошибиться.

### Повышение читаемости и поддерживаемости кода

Рассмотрим пример вычисления суммы элементов массива.

```js
// Плохой способ
let numbers = [1, 2, 3, 4, 5];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
  sum += numbers[i];
}
console.log(sum);
```

Даже если сумма элементов массива вычисляется всего один раз, вынос этой логики в отдельную функцию повышает читаемость и поддерживаемость кода. Становится сразу понятно, что именно делает данный участок программы.

```js
// Хороший способ
function calculateSum(array) {
  let sum = 0;

  for (let i = 0; i < array.length; i++) {
    sum += array[i];
  }

  return sum;
}

let numbers = [1, 2, 3, 4, 5];
console.log(calculateSum(numbers));
```

Теперь код становится более выразительным: вместо деталей реализации мы оперируем понятным именем функции. Такой подход упрощает сопровождение программы и делает её логику очевиднее как для вас, так и для других разработчиков.

## Объявление и вызов функции

### Объявление функции

Объявление функции в JavaScript состоит из _четырёх основных частей_:

- Ключевое слово `function`
- Имя функции
- Список параметров (в круглых скобках)
- Тело функции: набор инструкций, заключённых в фигурные скобки `{ }`

Общий синтаксис:

```js
function functionName(arg1, arg2, ..., argN) {
  // Тело функции
}
```

Данный способ объявления функции называется _Function Declaration_.

Например,

```js
// Функция без параметров
function printHelloWorld() {
  console.log('Hello, World!');
}

// Функция с параметрами
function sum(a, b) {
  // Ключевое слово return используется для возвращения результата
  return a + b;
}
```

### Вызов функции

Как вам уже известно из курса по основам программирования, для вызова функции используются круглые скобки `( )`.

В круглых скобках указываются аргументы, которые передаются функции.

```JS
function sum(a, b) {
  return a + b;
}

// Вызов функции sum с аргументами 2 и 3
sum(2, 3);
```

## Область видимости переменных функции

Из прошлой главы про [Переменные](../02_Syntax_Basics/readme.md#переменные) вам уже известно, что переменные могут иметь разную область видимости.

В JavaScript используется _лексическая (вложенная) область видимости_. Это означает, что функция имеет доступ не только к своим переменным, но и ко всем переменным, объявленным во внешних областях.

### Локальная область видимости

Переменные, объявленные внутри функции, доступны только внутри этой функции. За её пределами такие переменные не существуют.

Пример:

```js
function sum(arr) {
  let s = 0; // переменная s видна только внутри функции
  // ...
}

console.log(s); // ошибка: s не определена
```

Такие переменные называются _локальными переменными_.

### Доступ к внешним переменным

Функция имеет доступ ко всем переменным, объявленным в окружающих её областях видимости.

```js
let color = 'blue';

// Функция printColor выводит значение внешней переменной color
function printColor() {
  console.log(color);
}

// Функция changeColor изменяет значение внешней переменной color
function changeColor(newColor) {
  color = newColor;
}
```

> [!TIP]
>
> Важно понимать: переменная color не является _«глобальной» в абсолютном смысле_ - она просто находится во внешней области видимости по отношению к функции.

### Вложенные функции и цепочка областей видимости

Функции могут быть вложенными друг в друга. В этом случае внутренняя функция имеет доступ ко всем переменным, объявленным во всех внешних функциях.

```js
function outer() {
  let x = 10;

  function inner() {
    console.log(x); // 10
  }

  inner();
}
```

### Перекрытие переменных

Если внутри функции объявлена переменная с тем же именем, что и во внешней области, то внутренняя переменная перекрывает внешнюю.

```js
let color = 'blue';

function printDefaultColor() {
  let color = 'red';
  console.log(color); // "red"
}

console.log(color); // "blue"
```

В этом случае внутри функции используется локальная переменная `color`, а _внешняя остаётся неизменной_.

## Возвращение значения

Из определения выше вы уже знаете, что _функция_ - это блок кода, который может принимать аргументы и возвращать значение

Для возврата значения используется ключевое слово `return`, после которого указывается возвращаемое значение.

Примеры:

```js
// Пример №1: функция для вычисления суммы
function sum(a, b) {
  return a + b; // вернуть значение a + b
}

console.log(sum(2, 3)); // 5
console.log(sum(1, -1)); // 0
```

```js
// Пример №2: функция для проверки числа на чётность
function isEven(number) {
  if (number % 2 === 0) {
    return true; // вернуть true, если число чётное
  }

  return false; // вернуть false, если число нечётное
}

console.log(isEven(1)); // false
console.log(isEven(2312)); // true
```

> [!NOTE]
>
> Ключевое слово `return` может находиться в любом месте тела функции, не обязательно в его последней строке.
> Как только интерпретатор встречает `return`, выполнение функции немедленно прекращается, и управление возвращается в место вызова функции.

Важно помнить одну особенность: _в JavaScript любая функция всегда возвращает какое-то значение_.

Если в функции отсутствует ключевое слово `return`, либо оно используется без указания возвращаемого значения (например, `return;`), то такая функция неявно возвращает `undefined`.

```js
function test() {
  // В функции нет оператора return
  // но функция всё равно возвращает значение
  // как будто в конце было написано: return undefined;
}

console.log(test()); // undefined
```

## Параметры и аргументы функции

### Различие между параметрами и аргументами

Для начала разберёмся в различии между параметрами функции и аргументами.

_Параметры_ - это переменные, указанные в круглых скобках _при объявлении функции_.

```js
// a и b - параметры функции
function sum(a, b) {
  return a + b;
}
```

_Аргументы_ - это значения, которые передаются функции при её вызове.

```js
let x1 = 3;
let x2 = 5;
// x1 и x2 - аргументы функции
const sum = sum(x1, x2);
```

Важно не путать эти понятия:

- _параметры_ существуют только внутри объявления функции;
- _аргументы_ - это реальные значения, которые подставляются в параметры при вызове функции.

### Передача аргументов в функцию

Рассмотрим следующий пример кода:

```JS
// Функция, которая должна менять значения переменных a и b местами
function swap(a, b) {
  let buf = a;
  a = b;
  b = buf;
}

let x1 = 3;
let x2 = 4;
swap(x1, x2);
console.log(x1, x2);
```

Как вы думаете, какие значения будут выведены в консоль? На первый взгляд может показаться, что переменные `x1` и `x2` поменяются местами, и результатом будет `4` `3`. Однако этого не происходит - значения `x1` и `x2` остаются прежними: `3` и `4`.

Причина такого поведения заключается в следующем:

1. _Аргументы передаются в функцию по значению_. Это означает, что при вызове функции значение `x1` копируется в параметр `a`, а значение `x2` - в параметр `b`.
2. _Изменения происходят только внутри функции_. Внутри функции swap переменные `a` и `b` действительно меняются местами, но это лишь локальные копии.
3. _После завершения функции внешние переменные не изменяются_. Переменные `x1` и `x2` никак не затрагиваются, так как функция работала не с ними, а с их копиями.

Такое поведение характерно для примитивных типов данных (`number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`).

> [!NOTE]
>
> Важно понимать, что при работе с _объектами_ и _массивами_ ситуация будет иной. В этих случаях функция может изменить содержимое переданного значения. К этому мы вернёмся позже.

### Параметры по умолчанию

Если при вызове функции не передать аргумент, соответствующий параметр автоматически получит значение `undefined`.

Пример:

```js
function print(a) {
  // Если параметр a не передан, он равен undefined
  console.log(a);
}

print(); // undefined
```

Чтобы избежать такого поведения, в JavaScript можно задать _значение параметра по умолчанию_. Это значение будет использовано, если аргумент не был передан при вызове функции.

Пример:

```js
function sendMessage(text = 'Привет, как дела?') {
  console.log('Отправлено сообщение: ' + text);
}

// Вызов функции без аргумента
sendMessage(); // Отправлено сообщение: Привет, как дела?

sendMessage('Привет'); // Отправлено сообщение: Привет
```

Параметры со значениями по умолчанию должны располагаться в конце списка параметров. В противном случае JavaScript не сможет корректно сопоставить аргументы с параметрами.

```js
function func(a, b = 3, c) {} // Неверно

function func(a, c, b = 3) {} // Верно
```

### Остаточные параметры

Представьте себе функцию, которая ищет максимальное число среди переданных значений. Целесообразно ли создавать отдельную функцию под каждое количество аргументов:
`max(a, b)`, `max(a, b, c)`, `max(a, b, c, d)` и так далее? _Очевидно, что нет_.

В таких случаях в JavaScript можно объявить _функцию с произвольным количеством аргументов_. Такие параметры называются _остаточными параметрами_.

Общий синтаксис:

```js
function func(...args) {
  // тело функции
}
```

- `...args` означает, что функция может принимать любое количество аргументов: func(1, 2), func(2, 3, 4, 5) и т.д.

> [!TIP]
>
> Оператор `...` называется _spread/rest оператором_. Подробнее он будет рассмотрен в теме про массивы.

Параметр `args` внутри функции представляет собой массив, содержащий все переданные аргументы. Например, при вызове `func(2, 3, 4, 5)` переменная args будет равна `[2, 3, 4, 5]`.

Рассмотрим пример функции, которая находит максимальное число:

```js
/**
 * Находит наибольшее значение среди переданных аргументов.
 * @param {...number} values - Значения для сравнения.
 * @returns {number} - Наибольшее значение.
 */
function max(...values) {
  let maxValue = values[0];

  for (let i = 1; i < values.length; i++) {
    if (values[i] > maxValue) {
      maxValue = values[i];
    }
  }

  return maxValue;
}

// Функцию можно вызывать с любым количеством аргументов:
console.log(max(1, 2, 3)); // 3
console.log(max(66, 34, 789, -30, 3094)); // 3094

// Как думаете, что будет выведено на экран?
console.log(max()); // ?
```

> [!NOTE]
>
> Несмотря на удобство использования остаточных параметров, _рекомендуется всегда учитывать пограничные случаи_. Например, ситуацию, когда пользователь не передал ни одного аргумента, хотя функция логически предполагает наличие как минимум одного значения.

Остаточные параметры можно использовать _вместе с обычными параметрами_. В этом случае обычные параметры принимают первые аргументы, а все остальные собираются в массив остаточных параметров.

```js
/**
 * Функция складывает переданные аргументы и умножает результат на множитель.
 * @param {number} multiplier - Множитель для умножения.
 * @param {...number} numbers - Числа для сложения.
 * @returns {number} - Результат умножения суммы чисел на множитель.
 */
function multiplySum(multiplier, ...numbers) {
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
  }
  return sum * multiplier;
}
```

Обязательным правилом является то, что остаточные параметры должны следовать после всех остальных параметров функции.

```js
// Возникнет ошибка, поскольку остаточные параметры должны быть последними в списке параметров функции.
function multiplySum(...numbers, multiplier) { // так нельзя.
    // ...
}
```

Остаточные параметры можно использовать вместе с обычными параметрами. В этом случае обычные параметры принимают первые аргументы, а все остальные собираются в массив остаточных параметров.

```js
/**
 * Функция складывает переданные числа и умножает результат на множитель.
 * @param {number} multiplier - Множитель.
 * @param {...number} numbers - Числа для сложения.
 * @returns {number} - Результат умножения суммы на множитель.
 */
function multiplySum(multiplier, ...numbers) {
  let sum = 0;

  for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
  }

  return sum * multiplier;
}
```

Важно помнить обязательное правило: _остаточные параметры всегда должны быть последними в списке параметров функции_.

```js
// Ошибка: остаточный параметр должен быть последним
function multiplySum(...numbers, multiplier) {
  // ...
}
```

## Function Expression

В предыдущей части главы вы познакомились со стандартным синтаксисом объявления функции, который называется `Function Declaration`.

```js
function func(a, b) {
  // ...
}
```

Существует еще один способ, который также является используемым.

### Что такое функция в контексте JavaScript?

Перед тем как разбирать синтаксис и приёмы работы с функциями, важно понять одну фундаментальную вещь.

_В JavaScript любая функция - это значение_. Независимо от способа объявления, функция является обычным значением языка.

Проще говоря, функция в JavaScript - это такое же значение, как число `2` или строка `"text"`, просто над этим значением доступна особая операция - _вызов_.

Из этого напрямую следует несколько важных последствий:

1. Функции можно _присваивать переменным_.
2. Функции можно _передавать как аргументы в другие функции_.
3. Функции можно _сохранять в массивах и других структурах данных_.

Рассмотрим простой пример:

```js
function div(a, b) {
  return a / b;
}

// Копируем значение функции div в переменную oneMoreDiv
// Круглые скобки НЕ используются, иначе функция будет вызвана
let oneMoreDiv = div;

oneMoreDiv(6, 2); // 3
```

Здесь мы не вызываем функцию `div`, а присваиваем переменной `oneMoreDiv` ссылку на ту же функцию. Обе переменные теперь указывают на один и тот же объект функции в памяти. Именно поэтому обе работают идентично.

JavaScript позволяет и более необычные, на первый взгляд, конструкции:

```js
if (
  function sum(a, b) {
    return a + b;
  }
) {
  // В консоль выведется "What?",
  // так как функция - это значение, приводимое к true
  console.log('What?');
}

// Или ...

console.log(function a() {} + 3); // Результат здесь будет строкой "function a() {}3", так как функция неявно приводится к строке, а затем выполняется конкатенация.
```

Если функция - это значение, то имя функции - это просто имя переменной, в которой хранится ссылка на функцию:

```js
function sub(a, b) {
  return a - b;
}

function mul(a, b) {
  return a * b;
}

// Теперь переменная sub больше не ссылается на функцию вычитания,
// а указывает на функцию умножения
sub = mul;

sub(4, 3); // 12
```

Все становится на свои места, если воспринимать функции как просто значения, с которыми можно работать так же, как с другими значениями - только еще и вызывать.

### Синтаксис Function Expression

Раз функция - это значение, её можно создавать прямо «на месте» в виде выражения и сразу присваивать переменной. Один из способов создания функции в JavaScript называется *Function Expression* (функциональное выражение).

*Function Expression* - это способ создания функции, при котором функция объявляется как часть выражения, чаще всего в момент присваивания значения переменной.

Когда функция записана прямо в выражении (например, в правой части присваивания), её часто называют *функциональным литералом* - это буквально «значение функции, записанное прямо в коде».

Пример:

```js
const add = function (a, b) {
   return a + b;
}
```

В этом коде:

- `function (a, b) { ... }` - это значение функции (функциональный литерал);
- это значение присваивается константе `add`;
- после этого функцию можно вызывать по имени переменной `add`.

```js
add(2, 3); // 5
```

Обратите внимание: после ключевого слова `function` здесь нет имени функции. Для Function Expression это нормально: функция может быть *анонимной*.

> [!TIP]
>
> Функции без имени называются *анонимными функциями*.

### Различия Function Declaration и Function Expression

Выделим основные различия между *Function Declaration* (объявление функции) и *Function Expression* (функциональное выражение).

####  Способ объявления

- *Function Declaration* объявляется с использованием ключевого слова `function` и имеет имя.
- *Function Expression* объявляется как часть выражения и, как правило, присваивается переменной. 

#### Hoisting

- *Function Declaration* можно вызывать до её объявления в коде в пределах области видимости. Это происходит потому, что объявления функций поднимаются целиком.
  ```js
  add(1, 2); // 3 (будет вызвана)

   function add(a, b) {
      return a + b;
   }

   add(1, 2); // 3 (будет вызвана)
   ```
- *Function Expression* можно вызывать только после её объявления. До этого момента переменная ещё не содержит значение функции.
  ```js
  add(1, 3); // Ошибка. add не объявлена.

   const add = function (a, b) {
      return a + b;
   }

   add(1, 3); // 4 (будет вызвана)
   ```

### Когда использовать Function Declaration и Function Expression?

Используйте *Function Declaration*, если:

- функция должна быть доступна в любом месте своей области видимости, в том числе до её объявления;
- функция играет важную роль в основной логике программы;
- к функции требуется доступ из разных частей кода.

Используйте *Function Expression*, если:

- функцию нужно определить в контексте выражения;
- вы хотите присвоить функцию переменной;
- функцию необходимо передать как аргумент в другую функцию;
- функция используется локально внутри определённого блока кода и не должна быть доступна извне.s

## Теперь вы знаете ...

1. Что такое функция в программировании и в JavaScript, чем она отличается от математической функции и почему без функций невозможно писать поддерживаемый код.
2. Зачем использовать функции - для устранения дублирования кода, повышения читаемости и упрощения сопровождения программ.
3. Как объявлять и вызывать функции с помощью Function Declaration, из каких частей состоит объявление функции и как происходит её вызов.
4. Как работает область видимости функций, что такое локальные и внешние переменные, вложенные функции и перекрытие имён.
5. Как функции возвращают значения, что делает оператор return и почему любая функция в JavaScript всегда возвращает значение (даже если return не указан).
6. Чем параметры отличаются от аргументов, как аргументы передаются в функцию и почему примитивные значения передаются по значению.
7. Как использовать параметры по умолчанию и остаточные параметры, в каких случаях они полезны и какие ограничения при этом существуют.
8. Почему функция в JavaScript - это значение, что такое функциональный литерал и почему имя функции - это имя переменной, в которой хранится функция.
9. Что такое Function Expression, чем он отличается от Function Declaration и как работает hoisting для каждого из этих способов объявления.
10. Когда и какой способ объявления функций использовать в зависимости от задачи и структуры кода.