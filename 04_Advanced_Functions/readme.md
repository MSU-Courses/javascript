# Продвинутые функции: стрелочные функции, функции обратного вызова

## Содержание

- [Продвинутые функции: стрелочные функции, функции обратного вызова](#продвинутые-функции-стрелочные-функции-функции-обратного-вызова)
  - [Содержание](#содержание)
  - [Стрелочные функции](#стрелочные-функции)
    - [Что такое стрелочные функции](#что-такое-стрелочные-функции)
    - [Сокращённая форма стрелочных функций](#сокращённая-форма-стрелочных-функций)
    - [Многострочные стрелочные функции](#многострочные-стрелочные-функции)
    - [Важное замечание](#важное-замечание)
  - [Функции обратного вызова (callback)](#функции-обратного-вызова-callback)
    - [Что такое функции обратного вызова?](#что-такое-функции-обратного-вызова)
    - [Применение функций обратного вызова](#применение-функций-обратного-вызова)
      - [Зачем использовать функции обратного вызова?](#зачем-использовать-функции-обратного-вызова)
      - [Пример №1](#пример-1)
      - [Пример №2](#пример-2)
    - [Определение callback-функции непосредственно при вызове функции](#определение-callback-функции-непосредственно-при-вызове-функции)
  - [Именованные и анонимные функции](#именованные-и-анонимные-функции)
  - [Замыкания в JavaScript (необязательная)](#замыкания-в-javascript-необязательная)
    - [Что такое замыкание?](#что-такое-замыкание)
    - [Использование замыканий](#использование-замыканий)
  - [Теперь вы знаете ...](#теперь-вы-знаете-)

## Стрелочные функции

В предыдущей главе вы познакомились с понятием _Function Expression_ - способом объявления функции с помощью функционального литерала и последующего присваивания её переменной или константе.

Вспомним этот синтаксис:

```js
const add = function (a, b) {
  return a + b;
};
```

Такой способ объявления функций является полностью корректным, но на практике он может выглядеть _довольно громоздким_, особенно когда функции короткие и используются часто. Поэтому в стандарте ES6 была предложена более компактная альтернатива - _стрелочные функции_.

### Что такое стрелочные функции

_Стрелочные функции (arrow functions)_ - это синтаксическая форма записи функций, появившаяся в ES6. Они используют оператор `=>` и позволяют писать функции короче и выразительнее.

Общий синтаксис:

```js
const func = (arg1, arg2, ...argN) => {
  // тело функции
};
```

Пример:

```js
const add = (a, b) => {
  return a + b;
};

console.log(add(2, 3)); // 5
```

### Сокращённая форма стрелочных функций

Если стрелочная функция _состоит из одного выражения и просто возвращает результат_, можно опустить:

- фигурные скобки `{ }`
- ключевое слово `return`

```js
const add = (a, b) => a + b;
```

В этом случае результат выражения `a + b` будет возвращён автоматически.

> Попробуйте самостоятельно написать стрелочную функцию, которая в зависимости от чётности числа возвращает строку `"Чётное число"` или `"Нечётное число"`, _не используя `return`_.

Если функция принимает _ровно один аргумент_, круглые скобки можно опустить:

```js
const sqr = (num) => num ** 2;
```

Это эквивалентно следующей записи:

```js
const sqr = (num) => num ** 2;
```

Обе формы корректны. _Использование скобок - вопрос стиля и соглашений в команде_.

Если же функция _не принимает аргументов_, круглые скобки обязательны:

```js
const sayHello = () => {
  console.log('Hello');
};
```

### Многострочные стрелочные функции

Если стрелочная функция содержит _несколько инструкций_, то есть её тело занимает больше одной строки, обязательно используются фигурные скобки `{}`. В этом случае поведение функции становится максимально похожим на привычное объявление через function.

Пример:

```js
/**
 * Функция меняет местами элементы массива по заданным индексам.
 *
 * @param {Array} arr - Массив.
 * @param {number} a - Первый индекс.
 * @param {number} b - Второй индекс.
 */
const swap = (arr, a, b) => {
  const temp = arr[a];
  arr[a] = arr[b];
  arr[b] = temp;
};

// Пример использования
const array = [1, 2];

swap(array, 0, 1); // [2, 1]
```

Здесь тело функции состоит из нескольких шагов:

- Сохранение значения одного элемента во временную переменную.
- Перезапись элемента по первому индексу.
- Перезапись элемента по второму индексу.

### Важное замечание

На данном этапе стрелочные функции можно воспринимать как _упрощённый синтаксис Function Expression_. Однако у них есть и другие особенности, которые отличают их от обычных функций. Эти различия мы рассмотрим в следующих главах.

Пока достаточно уверенно понимать:

- как объявлять стрелочные функции;
- как использовать сокращённый синтаксис;
- в каких случаях нужны скобки и `return`.

Это знание понадобится вам уже в ближайших темах.

## Функции обратного вызова (callback)

Ещё одной неотъемлемой частью JavaScript, да и в целом любого функционального языка программирования, являются _функции обратного вызова_ (callbacks). С ними вы будете сталкиваться постоянно в процессе изучения JavaScript - настолько часто, что со временем перестанете замечать их как нечто отдельное. Они используются буквально повсюду: при работе с массивами, событиями, таймерами, асинхронными операциями.

В начале эта тема почти всегда кажется сложной и немного «скользкой». Функция, которую мы не вызываем сами, а передаём куда-то и надеемся, что её вызовут позже, - звучит непривычно. Но это ощущение быстро проходит.

### Что такое функции обратного вызова?

_Функция обратного вызова (callback, колбэк)_ - это функция, которая передаётся в другую функцию в качестве аргумента и вызывается позднее, внутри неё.

Как вы уже могли заметить, в JavaScript функцию можно использовать так же, как и любое другое выражение: передавать, присваивать переменным и вызывать в нужный момент.

Пример:

```js
function func(number, otherFunc) {
  // ...
  let a = 3;
  let b = 4;
  otherFunc(a, b); // вызов функции `otherFunc` внутри функции `func`
}

function otherFunc(a, b) {
  return a + b;
}

func(1, otherFunc); // передаём функцию в качестве аргумента
```

В приведённом примере функция `otherFunc` является функцией обратного вызова.

### Применение функций обратного вызова

#### Зачем использовать функции обратного вызова?

Самый частый и, пожалуй, самый логичный вопрос, который возникает при изучении этой темы: _зачем вообще использовать колбэки_? _Зачем передавать одну функцию в другую и усложнять код_?

На самом деле ответ достаточно простой. Функции обратного вызова позволяют грамотно разделять логику и делать код более гибким. Одна функция может отвечать за общий алгоритм или процесс, а другая - за конкретное действие, которое выполняется в определённый момент.

Такой подход помогает:

- _Разделять ответственность_. Одна функция управляет процессом, другая - выполняет конкретную операцию.
- _Переиспользовать код_. Основная функция остаётся неизменной, а поведение можно менять, передавая разные колбэки.
- _Упрощать поддержку_. Логику проще читать, тестировать и изменять по частям, не затрагивая весь код целиком.

> [!NOTE]
>
> Это можно представить как аналог объектно-ориентированного подхода в функциональном мире: вместо передачи объектов с методами мы передаём функции, которые определяют поведение.

Рассмотрим два примера использования колбэков.

#### Пример №1

Реализуем функцию, которая обрабатывает соглашение пользователя. Если пользователь ответил «Да» - нужно отобразить положительное сообщение, если «Нет» - отрицательное.

```js
/**
 * Обработка соглашения пользователя
 * isAgree - булево значение, указывающее, согласен ли пользователь
 */
function userAgree(isAgree) {
  if (isAgree) {
    console.log('Пользователь согласен');
    // Дальнейшая обработка в случае согласия пользователя
    // Например, показать ему опрос.
    return;
  }

  console.log('Пользователь не согласен');
  // Дополнительная обработка в случае отказа пользователя
  // Например, переадресовать на главную страницу.
}

const isUserAgree = confirm('Вы согласны участвовать в опросе?');

userAgree(isUserAgree);
```

На первый взгляд код выглядит рабочим, но у функции `userAgree` появляется слишком много ответственностей. Она одновременно: принимает решение, выводит сообщения, содержит логику обработки согласия и отказа. Это плохой признак, функция становится трудно расширяемой и плохо переиспользуемой.

Перепишем этот пример с использованием функций обратного вызова.

```js
function userAgree(isAgree, yes, no) {
  if (isAgree) {
    yes();
    return;
  }

  no();
}

// функция для обработки согласия пользователя
function processAgreement() {
  console.log('Пользователь согласен');
  // Дальнейшая обработка в случае согласия пользователя
}

// функция для обработки отказа пользователя
function processDisagreement() {
  console.log('Пользователь не согласен');
  // Дополнительная обработка в случае отказа пользователя
}

const isUserAgree = confirm('Вы согласны участвовать в опросе?');

userAgree(isUserAgree, processAgreement, processDisagreement);
```

Теперь обязанности чётко разделены:

- Функция `userAgree` отвечает только за принятие решения.
- Функции `processAgreement` и `processDisagreement` отвечают за конкретное поведение.

Такой код проще читать, легче изменять и безопаснее расширять. Разработчик может менять логику обработки согласия или отказа, не затрагивая основную функцию `userAgree`, которая продолжает выполнять свою ключевую задачу.

#### Пример №2

Реализуем функцию, которая выполняет пользовательскую операцию над двумя числами. Идея простая: мы передаём два значения и функцию, описывающую операцию, которую нужно над ними выполнить (например, сложение).

```js
/**
 * Применяет пользовательскую операцию к двум числам.
 *
 * @param {number} a - Первое число.
 * @param {number} b - Второе число.
 * @param {Function} operation - Функция операции.
 */
function applyOperation(a, b, operation) {
  return operation(a, b);
}

function sum(a, b) {
  return a + b;
}

function mul(a, b) {
  return a * b;
}

function customOperation(a, b) {
  return a * (1 + 2 * b);
}

applyOperation(2, 3, sum); // 5
applyOperation(2, 3, mul); // 6
applyOperation(2, 3, customOperation); // 14
```

В этом примере функция `applyOperation` не знает, какую именно операцию она выполняет. Её задача - принять два числа и переданную функцию, а затем корректно применить её к аргументам. Все конкретные операции (`sum`, `mul`, `customOperation`) вынесены отдельно и могут свободно изменяться или дополняться без изменения самой функции `applyOperation`.

> Попробуйте реализовать функцию `applyOperation(a, b)` без использования функций обратного вызова.

### Определение callback-функции непосредственно при вызове функции

В ряде случаев бывает удобнее определять callback-функцию не отдельно, а _прямо в момент вызова основной функции_. Такой подход часто делает код компактнее и позволяет сразу увидеть, что именно происходит в конкретном месте программы.

```js
function applyOperation(a, b, operation) {
  return operation(a, b);
}

// Определение callback-функции
// непосредственно при вызове applyOperation
applyOperation(1, 2, (a, b) => {
  return a + b;
});

// Стрелочную функцию можно упростить
applyOperation(1, 2, (a, b) => a + b);
```

В этом случае функция-операция не выносится в отдельное объявление, а описывается прямо там, где используется. Это особенно удобно, когда логика проста и не предполагает повторного использования.

Преимущества такого подхода:

- _Краткость кода_. Меньше объявлений, меньше «шума», легче воспринимать поток выполнения.
- _Локальная область видимости_. Callback-функция существует только в месте вызова, что повышает модульность и снижает вероятность побочных эффектов.

Однако важно понимать и ограничения. Если callback становится громоздким или содержит сложную логику, такой код быстро теряет читаемость и становится трудным для понимания.

> [!IMPORTANT]
>
> Общая рекомендация следующая: если callback-функция используется в одном месте и содержит небольшое количество инструкций (примерно 3–4), её допустимо и удобно определять непосредственно при вызове. В остальных случаях лучше вынести её в отдельную именованную функцию.

## Именованные и анонимные функции

Ещё одним важным аспектом JavaScript являются анонимные функции. С ними вы уже сталкивались в предыдущей теме, поэтому здесь имеет смысл кратко обобщить материал, чтобы было проще их различать на практике.

Если после ключевого слова `function` указано имя, функция считается _именованной_. Во всех остальных случаях функция является _анонимной_. При этом способ объявления (Function Declaration, Function Expression) сам по себе не определяет, будет функция анонимной или нет - решающим является наличие имени.

```js
// анонимная функция (стрелочная)
const sum = (a, b) => {
  return a + b;
};

// именованная функция
const sum = function sum(a, b) {
  return a + b;
};

// в качестве аргумента передаётся анонимная функция
applyOperation(4, 5, function (a, b) {
  return a + b;
});

// в качестве аргумента передаётся именованная функция
applyOperation(4, 5, function sum(a, b) {
  return a + b;
});
```

## Замыкания в JavaScript (необязательная)

> [!NOTE]
>
> Данная тема является необязательной и служит для углубления знаний.

### Что такое замыкание?

В предыдущей теме вы уже увидели, что функция в JavaScript имеет доступ к области видимости родительской функции.

```js
function foo() {
  let a = 30;

  function func() {
    console.log(a);
  }

  func();
}

foo(); // 30
```

У функции `func` нет собственных локальных переменных, но она имеет доступ к переменной `a`, объявленной в родительской функции `foo`. Это возможно потому, что _JavaScript ищет переменные не только внутри функции, но и выше_ - в её лексическом окружении. На этом этапе всё выглядит довольно логично и не вызывает вопросов.

Однако интересный момент появляется тогда, когда внешняя функция завершает выполнение, а вложенная функция продолжает существовать.

Рассмотрим пример:

```js
function createMessage() {
  let message = 'Hello';

  function showMessage() {
    console.log(message);
  }

  return showMessage;
}

const sayHello = createMessage();

sayHello(); // Hello
```

В примере выше функция `createMessage` уже отработала и казалось бы, что локальные переменные должны были пропать, но вызвав функции `sayHello()` оказалось, что сообщение `Hello` вывелось, то есть возвращенная функция все еще имеет доступ к переменной `message`.

Такое поведение называется - _замыканием_.

_Замыкание_ - это функция вместе с теми переменными, которые были доступны ей в момент создания. Даже если выполнение внешней функции завершилось, вложенная функция всё равно «помнит» эти переменные и может с ними работать.

Важно не запоминать определение, а уловить идею:

- функция создаётся в определённом контексте;
- JavaScript сохраняет этот контекст;
- функция может использовать переменные из него позже.

> [!NOTE]
>
> _Замыкания_ - это не отдельная конструкция языка, а естественное следствие того, как работают функции и области видимости в JavaScript.

### Использование замыканий

Может возникнуть логичный вопрос: зачем вообще использовать замыкания? На практике есть множество ситуаций, где они оказываются очень полезными.

Рассмотрим простой и наглядный пример - реализуем _счётчик_, значение которого можно _увеличивать_ и _уменьшать_ только на единицу. Сделаем это с помощью замыканий.

```js
function counter() {
  // Начальное значение счётчика
  // Используем let, так как значение будет изменяться
  let state = 0;

  // Увеличивает значение счётчика на 1
  const increase = () => {
    state++;
  };

  // Уменьшает значение счётчика на 1
  const decrease = () => {
    state--;
  };

  // Возвращает текущее значение счётчика
  const value = () => {
    return state;
  };

  // Возвращаем объект с методами
  // Прямого доступа к state нет
  return {
    increase,
    decrease,
    value,
  };
}

const ticker = counter();

ticker.increase();
ticker.increase();
console.log(ticker.value()); // 2

ticker.decrease();
console.log(ticker.value()); // 1
```

В этом примере переменная `state` недоступна напрямую из внешнего кода. Однако она не исчезает после выполнения функции `counter`, потому что используется во вложенных функциях - именно это и есть замыкание. Внешний код может управлять состоянием, но только через предоставленные функции `increase`, `decrease` и `value`.

Такой подход очень похож на ООП: данные скрыты; доступ к ним осуществляется через методы; внутреннее состояние защищено от прямого изменения. Хотя формально это пример _функционального программирования_, идея инкапсуляции здесь та же самая - мы не даём прямой доступ к данным, а предоставляем контролируемый интерфейс.

> Попробуйте изменить функцию `counter()` так, чтобы она принимала начальное значение счётчика.

## Теперь вы знаете ...

1. Что такое стрелочные функции, зачем они были добавлены в стандарт ES6 и почему на практике они используются чаще, чем классический Function Expression.
2. Как выглядит базовый синтаксис стрелочных функций, какие части в нём обязательны и какие можно опускать.
3. В каких случаях можно использовать сокращённую форму стрелочной функции, автоматически возвращающую результат выражения, и какие при этом существуют ограничения.
4. Почему при использовании многострочных стрелочных функций фигурные скобки `{}` являются обязательными и чем такое поведение отличается от однострочного варианта.
5. Что такое функции обратного вызова (callback-функции) и почему передача функции в качестве аргумента является естественной и фундаментальной возможностью JavaScript.
6. Зачем используются callback-функции: для разделения ответственности, повышения гибкости и переиспользуемости кода.
7. Как применять функции обратного вызова на практике на простых и наглядных примерах - от обработки пользовательского выбора до реализации пользовательских операций над данными.
8. Чем отличаются анонимные и именованные функции, и почему наличие имени определяется не способом объявления, а его явным указанием после ключевого слова `function`.
9. Какие общие рекомендации стоит соблюдать при работе с callback-функциями, чтобы код оставался понятным, расширяемым и удобным для сопровождения.
