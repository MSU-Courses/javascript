# Функции

Функции играют ключевую роль в языке программирования JavaScript, обеспечивая модульность, повторное использование кода и организацию программного кода в более управляемые блоки.

Можно ли обойтись без них, спросите Вы? Ответ очевиден: нельзя!

При работе над программами часто возникает необходимость повторять один и тот же фрагмент кода в разных частях программы. Именно для таких ситуаций и используются функции. Они позволяют избежать дублирования кода, делая его более компактным и удобным для поддержки.

Кроме того, функции могут служить для выделения и разделения определенных логических блоков, что делает программу более структурированной и понятной для разработчика

Учитывая ваш опыт работы с функциями в C++ и знакомство с некоторыми функциями в JavaScript (например, `alert()`, `prompt()` и другие), вы уже знаете некоторые их аспекты. Тем не менее в JavaScript функции могут проявлять себя по-другому и даже сбивать с толку опытных разработчиков.

## Когда нужны функции?

Как было сказано выше, существует в основном две причины, когда мы выносим код в функцию.
1. Избежание повторного использования кода и обеспечение его переиспользования в различных частях программы.
2. Повышение читаемости и поддерживаемости кода.

Рассмотрим каждую из ситуаций.

**Ситуация №1**. 

Рассмотрим на примере вычисления площади круга.
```js
// Плохой способ: повторение кода

// Файл: index.js
let circleRadius = 5;
let circleArea = Math.PI * circleRadius ** 2;
console.log("Площадь круга:", circleArea1);

// Файл: calculate.js
let circleRadius = 10;
let circleArea = Math.PI * circleRadius ** 2;
console.log("Площадь круга:", circleArea1);

// т.е. в разных частях программы мне переписывать один и тот же код
```
```js
// Хороший способ: использование функций для повторяющихся операций

// Функция для вычисления площади круга
function calculateCircleArea(radius) {
    return Math.PI * radius ** 2;
}

// Файл: index.js
let circleRadius = 5;
console.log("Площадь круга:", calculateCircleArea(5));

// Файл: calculate.js
let circleRadius = 5;
console.log("Площадь круга:", calculateCircleArea(5));
```

**Ситуация №2**.

Рассмотрим на примере вычисления суммы элементов массива
```js
// Плохой способ, особенно если Ваш проект большой
let numbers = [1, 2, 3, 4, 5];
let sum = 0;
for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
}
console.log(sum);
```
```js
// Хороший способ
function calculateSum(array) {
    let sum = 0;
    for (let i = 0; i < array.length; i++) {
        sum += array[i];
    }
    return sum;
}

let numbers = [1, 2, 3, 4, 5];
console.log(calculateSum(numbers));
```
Данная ситуация (№2) более подходит для крупных проектов с большим объемом кода. Однако, если вы работаете с небольшим js файлом, использование функций иногда может усложнить понимание.

## Объявление функции

Объявление функции состоит из следующих частей:
* Ключевого слова `function`
* Списка параметров
* Тела функции: инструкций (кода), заключенных между фигурными скобками `{ }`.

Для того чтобы **объявить функцию**, используется следующий синтаксис:
```js
function functionName(arg1, arg2, ..., argN) {
    // тело функции
}
```

Например,
```js
// функция без параметров
function printHelloWorld() {
    console.log("Hello, world!");
}

// функция с параметрами
function sum(a, b) {
    return a + b;
}
```

> [!NOTE]
> Этот способ объявления функции называется **Function Declaration**.

## Область видимости переменных функции

Из главы [Переменные](../2_basics/22_variables.md) вам известно, что переменные могут быть локальные и глобальные.

Переменные, объявленные внутри функции, видны только в этой функции и считаются локальными.
```js
function sum(arr) {
    let sum; // видна только в пределах функции 
    // ...
}
console.log(sum); // ошибка
```

Переменные, объявленные вне функции, доступны внутри этой функции. Она имеет возможность изменять их значение.
```js
let color = "blue";

// Функция printColor выводит значение переменной color в консоль.
function printColor() {
    console.log(color);
}

// Функция changeColor принимает новый цвет в качестве аргумента
// и изменяет значение глобальной переменной color.
function changeColor(newColor) {
    color = newColor;
}
```

Если в функции указана одноименная локальная переменная, то она перекрывает значение глобальной переменной с тем же именем внутри функции.
```js
let color = "blue";

function printDefaultColor() {
    let color = "red";
    console.log(color); // red
}
```

> [!IMPORTANT]
> Использование глобальных переменных **не является хорошей практикой**, так как они могут привести к конфликтам имён, затруднить отслеживание и управление состоянием приложения, а также сделать код менее читаемым и поддерживаемым.

## Возвращение значения

Из определения, **функция** - это подпрограмма (блок кода), который может принимать аргументы и возвращать значение.

Для возвращения значения используется ключевое слово `return`.
```js
// Пример №1: Функция для вычисления суммы
function sum(a, b) {
    return a + b; // вернуть значение a + b
}

// Пример №2: Функция для проверки числа на четность
function isEven(number) {
    if (number % 2 === 0) {
        return true; // вернуть true, если число четное
    } else {
        return false; // вернуть false, если число нечетное
    }
}
```

> [!NOTE]
> Ключевое слово `return` может быть размещено в любом месте тела функции, необязательно в его последней строке. Когда интерпретатор встречает это ключевое слово, он мгновенно завершает выполнение функции и возвращает указанное значение.

Если в функции отсутствует ключевое слово `return`, либо оно присутствует без возвращаемого значения, как, например, `return;`, то такая функция вернёт значение undefined.

```js
// Пример №1
function greet(name) {
    console.log('Привет, ' + name + '!');
    // нет ключевого слова return
    // функция вернет undefined
}
let result = greet('Миша'); // result будет undefined

// Пример №2
function sayHello() {
    console.log('Привет, мир!');
    // нет явного возвращаемого значения
    // функция вернет undefined
    return;
}
let result = sayHello(); // result будет undefined
```

> [!NOTE]
> В JavaScript все функции возвращают какое-то значение.

## Параметры функции

Как уже известно, функции могут принимать параметры.

```js
// Параметр - это переменная, указанная в круглых скобках при объявлении функции.
// a, b — параметры функции
function sum(a, b) {
    return a + b;
}

let x1 = 3;
let x3 = 4;
// Аргумент - это значение, которое передается функции при её вызове.
// x1, x2 — аргументы
const s = sum(x1, x2); 
```

### Локальные переменные функции

Рассмотрим еще один интересный пример.
```js
// Фунция, которая должна менять значения переменных `a` и `b` местами
function swap(a, b) {
    let buf = a;
    a = b;
    b = buf;
}

let x1 = 3;
let x2 = 4;
swap(x1, x2);
console.log(x1, x2);
```

Как Вы думаете какие значения будут выведены на экран?
С одной стороны, смотря на код, можно предположить, что переменные x1 и x2 поменяют свои значения, и результатом будет  `x1 = 4`, `x2 = 3`.

Однако, переменные `x1` и `x2` не изменяют свои значения и они останутся прежними, потому, что функция только меняет свои локальные переменные.

Когда мы вызываем функцию swap с аргументами `x1` и `x2`, на самом деле происходит следующее: 
1. Значение `x1` копируется в переменную `a`, а значение `x2` копируется в переменную `b`.
2. Происходит обмен значений между `a` и `b`, но это происходит только внутри функции swap. 
3. После завершения выполнения функции, переменные `x1` и `x2` остаются неизменными, так как они остаются равными `3` и `4` соответственно. 
4. Таким образом, на экран будет выведено значение `x1 = 3`, `x2 = 4`, как и было изначально.

> [!IMPORTANT]
> Этот подход работает **только с примитивными типами данных**, такими как числа или строки и др. Однако, если мы попытаемся использовать функции с объектами или массивами, мы столкнемся с другим результатом.

### Значения по умолчанию

Если мы вызываем функцию и не передаём необходимые аргументы, их значения по умолчанию становятся **undefined**.

```js
function print(a) {
    console.log(a);
}

print(); // выведет `undefined`, так как аргумент не передан
```

Иногда возникает необходимость предоставить значения по умолчанию для аргументов функции, чтобы обеспечить более надёжную работу кода и избежать ошибок при вызове функции без передачи всех аргументов. Для этого используются **значения по умолчанию**.

Например,
```js
function sendMessage(text = 'Привет, как дела?') {
    console.log('Отправлено сообщение: ' + text);
}

// Вызов функции без передачи текста сообщения
sendMessage(); // Выведет: "Отправлено сообщение: Привет, как дела?"
sendMessage("Привет"); // Выведет: "Отправлено сообщение: Привет"
```

### Остаточные параметры

Возникают ситуации, когда нам неизвестно заранее, сколько параметров будет принимать функция.

Например, у нас может быть переменное количество аргументов, и мы хотим найти максимальное значение среди них.

Целесообразно ли создавать отдельную функцию для каждого количества аргументов, например, `max(a,b)`, `max(a, b, c)`, `max(a, b, c, d)`, и так далее? **Явно нет!**

Для этого используются функции **с произвольным количеством аргументов** или **функция с остаточными параметрами**.

```js
/**
 * Находит наибольшее значение среди переданных аргументов.
 * @param {...number} values - Значения для сравнения.
 * @returns {number} - Наибольшее значение из переданных аргументов.
 */
function max(...values) {
    let max = values[0];
    for (let i = 1; i < values.length; i++) {
        if (values[i] > max) {
            max = values[i];
        }
    }
    return max;
}

max(1,2,3);
max(66,34,789, -30, 3094);
// вызвать функцию можно с любым количеством аргументов
```

> [!IMPORTANT]
> Параметры values называются `остаточными параметрами` (rest parameters), и это позволяет функции принимать переменное количество аргументов.

Остаточные параметры будут доступны внутри функции **как обычный массив**, поэтому мы можем итерироваться по ним и обращаться к элементам массива так, как это делается в стандартном массиве.

Мы можем передавать в функцию как обычные аргументы, так и "остаточные" параметры.
```js
/**
 * Функция складывает переданные аргументы и умножает результат на множитель.
 * @param {number} multiplier - Множитель для умножения.
 * @param {...number} numbers - Числа для сложения.
 * @returns {number} - Результат умножения суммы чисел на множитель.
 */
function multiplySum(multiplier, ...numbers) {
    let sum = 0;
    for (let i = 0; i < numbers.length; i++) {
        sum += numbers[i];
    }
    return sum * multiplier;
}
```

Обязательным правилом является то, что остаточные параметры должны следовать после всех остальных параметров функции.

```js
// Возникнет ошибка, поскольку остаточные параметры должны быть последними в списке параметров функции.
function multiplySum(...numbers, multiplier) { // так нельзя.
    // ...
}
```

> [!NOTE]
> В данной главе мы рассмотрели параметр `...` (например, `...values`) - это оператор расширения. Пока не беспокойтесь о его деталях, просто запомните синтаксис. Мы подробно изучим этот оператор, когда будем рассматривать массивы.