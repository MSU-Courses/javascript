# Ключевое слово `this`

Из других языков программирования, таких как C++ и Java, вам уже известно о ключевом слове `this`.

В языке JavaScript ключевое слово `this` обозначает почти то же самое, что и в других языках программирования, однако оно обладает своими особенностями.

Многие не понимают, для чего оно используется и как его применять, поскольку оно действительно может вызвать много трудностей.

Мы ограничимся лишь основами данной темы и не будем углубляться в детали, поскольку это может затруднить дальнейшее понимание. 

Попытаемся разобрать данное ключевое слово сразу на практике.

## Ключевое слово `this` в объектах

### Предисловие

Рассмотрим задачу.  Предположим, у нас есть объект `player`, который содержит свойство `username`. Нам нужно создать метод объекта, который выводил бы приветствие и имя пользователя (`username`).

То есть,
```js
const player = {
    username: "Alex",
    greet() {
        // ...
    }
}

player.greet(); // "Hi, my name is Alex"
```

С одной стороны, кажется, что реализация несложная. Попробуем самый банальный способ:

```js
const player = {
    username: "Alex",
    greet() {
        console.log(`Hi, my name is ${username}`);
    }
}

// Uncaught ReferenceError: username is not defined
player.greet();
```

В данном случае выбрасывается ошибка, так как переменная `username` не определена в контексте функции `greet()`.

В других языках данное обращение сработало бы, но в JavaScript контекст выполнения функции `greet()` не подразумевает автоматическое распознавание переменной `username` как свойства объекта. Так как переменная `username` **не была определена внутри функции или не является глобальной переменной**, JavaScript не может найти ее в контексте выполнения функции `greet()`.

Проще говоря, можно сказать, что функция greet не имеет доступа к свойствам объекта, в частности, она не распознает переменную `username`.

Теперь попробуем это сделать по другому.

```js
const player = {
    username: "Alex",
    greet() {
        console.log(`Hi, my name is ${this.username}`);
    }
}

player.greet(); // "Hi, my name is Alex"
```

Теперь программа работает корректно, но мы добавили ключевое слово `this`. Уже поняли, что это такое?

Прежде чем понять, что такое `this`, попробуйте выполнить следующий код.

```js
const player = {
    name: "Alex",
    age: 23,
    greet() {
        console.log("Hi!");
    },
    displayThis() {
        console.log(this);
    }
}

player.displayThis();
// Будет выведено
/* 
{
    name: 'Alex',
    age: 23,
    greet: [Function: greet],
    displayThis: [Function: displayThis]
} 
*/
```

Стало более понятно? 

То есть, в контексте данного примера, в объекте `player` ключевое слово `this` указывает на сам объект `player`.

### `this` в контексте объектов

> [!NOTE]
> `this` в JavaScript - это ключевое слово, которое ссылается на текущий объект, в контексте которого оно используется.

То есть, более простыми словами, когда мы используем `this`, мы обращаемся к текущему объекту, в котором находится код, где это слово используется.

Еще один пример,

```js
const person = {
  name: 'Alice',
  age: 23,
  greet() {
    console.log(`Hello, my name is ${this.name}, i'm ${this.age} year old`);
  }
};

person.greet(); // Вывод: Hello, my name is Alice
```

Мы можем обойтись без ключевого слова `this`, но в данном случае такой способ не надежен при копировании объектов и **не рекомендуется для использования**.

```js
const person = {
    name: 'Alice',
    greet() {
        console.log(`Hello, my name is ${person.name}.`);
    }
}
```

## Контексты `this`

Теперь рассмотрим слово `this` более продвинуто, ведь его можно использовать практически везде.

Ключевое слово `this` не является фиксированным и может меняться в зависимости от контекста, в котором оно используется. То есть простыми словами, `this` зависит от того, где и как используется.

Исходя из этого можно сделать вывод, что, значения `this` будут разными, в зависимости от того, где и как используется.


> [!NOTE]
> **Контекст выполнения** - это область видимости, в которой выполняется код. В контексте выполнения определены переменные, функции, объекты и т.д.

Другими словами, контекст выполнения - это место, где код выполняется.

```js
// Код выполняется в глобальном контексте 
const a = 3;

const person = {
    name: 'Alice',
    greet() {
        // Код выполняется в контексте объекта person
        console.log(this);
    }
}
```

Значение `this` вычисляется во время выполнения кода. Это означает, что значение `this` зависит от того, где и как используется.

Давайте теперь рассмотрим, как и где `this` может использоваться.

_Эта тема может быть непонятной для многих студентов, но давайте попробуем рассмотреть её поверхностно._

### Глобальный контекст

> [!NOTE]
> **Глобальный контекст в JavaScript** — это базовый уровень программы, где не находится внутри функций или объектов. Когда мы работаем в глобальном контексте, this ссылается на глобальный объект.

Что будет если мы будем использовать `this` глобально? То есть зайдем в браузер или в консоль NodeJS и выведем значение `this`?

```js
console.log(this);
```

_Ответ простой_: если мы будем использовать `this` глобально в браузере или в консоли Node.js, то оно обычно будет указывать на глобальный объект (то есть будет глобальным объектом). В браузере это объект `window`, а в Node.js - объект `global`.

А что такое _глобальный объект_?

> [!NOTE]
> **Глобальный объект в JavaScript (`Global Object`)** представляет собой специальный объект, который доступен в любой точке кода в программе на JavaScript. В браузере глобальный объект называется window, а в среде выполнения Node.js - global.

Глобальный объект содержит множество встроенных свойств и методов, которые могут быть использованы в любом месте программы без явного обращения к объекту. **Например**, объект `console`, который помогаете выводить сообщения в консоль, хранится в глобальном контексте.

Глобальный объект также является местом, где хранятся глобальные переменные, которые могут быть доступны из любой точки программы. 

То есть мы можем представить нашу программу, как один большой объект.

### `this` в функциях

Когда мы используем `this` внутри функции, значение `this` зависит от того, как и где функция была вызвана.

Мы уже рассмотрели пример с объектом, то есть когда функция является методом объекта.

#### `this` в методах объекта

> [!NOTE]
> Если функция является свойством объекта (методом), то при использовании `this` в функции, будет использован контекст объекта.

Можно сказать, что функция, которая является методом объекта, "**привязана**" к этому объекту, это означает, что контекст выполнения данной функции является объект.

```js
const obj = {
    a: 1,
    b: [1, 2, 3],

    // Метод log, который выводит текущий объект в консоль
    // В данном случае this указывает на текущий объект,
    // так как этот метод будет вызываться из контекста объекта.
    log() {
        console.log(this);
    }
}

obj.log(); // { a: 1, b: [ 1, 2, 3 ], log: [Function: log] }
```

#### `this` в глобальном контексте функций

> [!NOTE]
> Когда мы создаем функцию в JavaScript и вызываем ее без явной связи с каким-либо объектом (например, в качестве метода), она работает в глобальном контексте.

Рассмотрим два примера.

```js
function logThis() {
    console.log(this);
}

// this указывает на глобальный объект
// так как функция вызывается в глобальном контексте
// В браузере: Window, в Node.js: global
logThis();
```

```js
const player = {
   greet() {
      const oneMoreGreet = function () {
         // Контекст выполнения будет глобальным объектом.
         // так как функция объявлена не как метод (то есть не привязана к объекту)
         console.log(this);
      }
   }
}
```

#### Изменение значения `this` в зависимости от контекста вызова функции

Одна и та же функция может использоваться в разных контекстах, и значение `this` будет разным в зависимости от контекста.

```js
// Определяем функцию greet(), которая выводит приветственное сообщение,
// используя свойство name объекта, на котором она вызывается
function greet() {
    console.log(`Hi, my name is ${this.name}`);
}

// Вызываем функцию greet() в глобальном контексте
// В данном случае, контекст выполнения функции - глобальный контекст.
// Поскольку в глобальном объекте нет свойства name, то this.name будет undefined
greet();

// Создаём объект player с свойством name и методом greet,
// который ссылается на функцию greet()
const player = {
    name: "Player", // Имя игрока
    // Присваиваем метод greet объекту player
    greet,
}

// Создаём объект user с свойством name и методом greet,
// который также ссылается на функцию greet()
const user = {
    name: "User", // Имя пользователя
    // Присваиваем метод greet объекту user
    greet, 
};

// Вызываем метод greet() объекта player
// Функция greet() выполняется в контексте объекта player,
// так что this.name внутри неё указывает на свойство name объекта player
player.greet(); // Hi, my name is Player

// Вызываем метод greet() объекта user
// Функция greet() выполняется в контексте объекта user,
// так что this.name внутри неё указывает на свойство name объекта user
user.greet(); // Hi, my name is User
```

### `this` в стрелочных функциях

Стрелочные функции немного отличаются от обычных. 

> [!NOTE]
> Одно из отличий заключается в том, что у стрелочных функций нет своего собственного `this`.

Когда мы используем `this` внутри стрелочной функции, оно не "привязывается" к текущему объекту, а берется из внешней функции или контекста, где эта функция была объявлена.

Рассмотрим пример,
```javascript
// Создание объекта player1
const player1 = {
    // Свойство username с именем "Alex"
    username: "Alex",
    // Метод greet() объекта player1
    greet() {
        // Внутри метода greet() объекта player1 создаётся обычная функция generateGreeting
        const generateGreeting = function() {
            // Возвращает приветственное сообщение, но this здесь не ссылается на объект player1, 
            // так как это обычная функция, поэтому this будет определено в глобальной области видимости или будет undefined
            return `Hello, my name is ${this.username}`;
        }
        // Значение this будет взято из глобального контекста
        return generateGreeting();
    }
}

player1.greet(); // Hello, my name is undefined

// Создание объекта player2
const player2 = {
    // Свойство username с именем "Alex"
    username: "Alex",
    // Метод greet() объекта player2
    greet() {
        // Внутри метода greet() объекта player2 создаётся стрелочная функция generateGreeting
        const generateGreeting = () => {
            // Стрелочная функция сохраняет контекст объекта, в котором она была определена,
            // поэтому this здесь будет ссылаться на объект player2
            return `Hello, my name is ${this.username}`;
        }
        // Значение `this` будет взято из внешнего контекста
       // В данном случае из контекста объекта player2
        return generateGreeting();
    }
}

player2.greet(); // Hello, my name is Alex
```

## Итог

1. Ключевое слово this:
   1. `this` - это ключевое слово, которое ссылается на текущий объект, в контексте которого оно используется.
   2. Значение `this` меняется в зависимости от контекста, в котором оно используется.
2. Контексты **this**:
   1. **Глобальный контекст**: this ссылается на глобальный объект (в браузере - window, в Node.js - global). 
   2. **Объекты**: this ссылается на текущий объект, в котором используется. 
   3. **Функции**: this зависит от того, как и где функция была вызвана.
   4. **Стрелочные функции**: у стрелочных функций нет собственного this. 